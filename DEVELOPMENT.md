InfoRec自述
=========

InfoRec是一个基于「非绝对时间」的事件记录和梳理工具。以「非绝对时间」为基础，InfoRec将可以提供许多功能，如梳理和细化事件的发生时间，检查多重记录源的冲突等。

什么是「非绝对时间」
--------

传统的记录工具（如日记或时间轴）均基于「**绝对时间**」，即一个日历上的特定日期加上一个钟表上的特定时分秒（或者还有毫秒等更精确时间）的组合。这些工具对于记录**新近**信息很合适。

但对于**过去**的信息，这些工具就有些乏力。无论是人的记忆还是史籍的记录，其中事件的发生时间大多并不十分确切，使用这些工具来记录就会难以梳理。但这些记录中对于事件的发生时间并非全然没有记录，却往往只有「绝对时间」中的一部分信息，如某某年某某月（没有具体几日以及几时几分），或是只有发生的相对顺序，如某事发生在某事之后。

这样的信息，就是这里所说的「**非绝对时间**」。

通过它们，虽然我们并不总是能够确切确定某件事的发生时间，但可以缩小检索范围，并且检查不可能的选项。对于个人日记，这样的记录也可以帮助回忆，或者是减少自己对于忘记某件事的担心。

目标
--------

最终目标是开发一个全功能的「非绝对时间」与「绝对时间」混合的事件记录和梳理工具，并提供一个WebUI。

其UI将允许新增、修改和检索已有条目。如果有能力，将提供一个（伪）时间轴来展示各个记录之间的关系。

除了使用非绝对时间来记录以外，InfoRec的另一大特色将是允许用户对不同信息源进行差分信任。这一灵感源自对「正史」和「野史」的区分，但泛化至任何的记录上——用户甚至可以自行选择不相互冲突的记录来组建自己的「史书」。


## 已完成功能

### 大功能

* 提供Jupyter Notebook使用范例`InfoRecExample.ipynb`
* 提供CLI入口`inforec.py`（不如用Notebook的全面，在考虑实现WebAPI后是否放弃）
* 实现了基础的对事件的记录存取，相互引用，冲突检查

### 细节

* 记录类型：
    * 事件
* 时间类型：
    * 相对于事件
    * 日期
    * 时间点
* 记录集合（Collection类）：
    * 增加
    * 检索
    * 更新
    * 完备性检查
* 冲突检查（OrderedMarkers类）
* 数据库维护（InfoRecDB类）


TODO
------

当下主要目标有：

1. 完善逻辑
    1. 支持更多记录类型（如时间片）
    2. 支持更多时间类型（如仅年，仅上中下午，仅上中下旬等）
    3. 完善冲突检查
    5. 支持富文本或其他记录内容
    4. 支持更多元数据信息（以独立「记录」的形式？）
        1. 两事件之间的相对时间差别
        2. 事件的「影响」关系
        3. 事件的「包含」关系
2. 提供简单UI
    1. 确定WebUI是否合适
    2. 提供Web API（选择RESTful？）
    3. 制作前端

可能的未来目标有：

1. 提供（伪）时间轴展示
2. 支持ontology互操作（导入导出，或者直接存储为ontology）
3. 支持导入导出（无论是否有ontology支持）
4. 支持更多日历类型（农历/夏历、儒略历等）并支持自动转换
5. 支持联邦（federated）记录


## 代码与开发细节

### 模块拆分

整体来看按所属种类拆分。未来或许会调整。

- 主要模块：
    - `inforec.py`：CLI入口
    - `model.py`：
        - **记录**与**时间**的模型，即各种记录类型和时间类型的相应类
        - 其中重点是`RelTimeMarker`（及其子类）、`RelTimeSpec`、`RelTimeSpecImplicit`以及`TimeRelativity`（见后文）
        - 它也包含了记录和时间的Builder
    - `sede.py`：序列化与反序列化（SErialize与DEserialize）
    - `storage.py`：各种存储类型，或许需要拆分
- 次要模块：
    - `exception.py`：会被多模块共用的异常类
    - `helper.py`：目前仅有一个修饰器
    - `notebook_util.py`：供Jupyter Notebook交互时使用的一些辅助函数
    - `utils.py`：通用的辅助函数

### 设计

#### 记录和时间

- **记录**是主要的数据，比如「事件」
- **时间**是每个记录需要包含的额外信息，以和其他记录相关联，用以实现「非绝对时间」

目前实现的记录只有「事件」（`Event`）一种类型。每个事件均包含一个`RelTimeSpec`，用来描述所用的「非绝对时间」。

`RelTimeSpec`内包含三种可能性：「在某某之前」、「在某某之后」与「和某某同时」。每种均需指向一个或多个`RelTimeMarker`（`Event`本身便是`RelTimeMarker`的子类之一）。这里有「空列表」和`None`的区分：空列表表示「已知为空」，而`None`表示不知道这个信息。

`RelTimeMarker`是可以被`RelTimeSpec`指向的信息。凡可作为「非绝对时间标记」的信息均应该是它的子类，比如`Event`或`AbsoluteDateTime`。

如`AbsoluteDateTime`和`Date`这种对应了一定真实时间的时间信息，其内生有顺序信息，即使两者并不属于同一类型。比如`2020-12-31`（日期）一定比`2020-12-30 12:00:00`（时间日期）要**晚**；再比如`2020-12-31`包含`2020-12-31 12:00:00`。为了处理这种情况，`RelTimeSpecImplicit`便被提出，要求它们均实现该类，并且实现`compare()`方法以自动推导该顺序信息。相应的，`TimeRelativity`作为其返回值。

#### 引用

为了可以动态修改，并且为了避免无法支持**环**，所有的`RelTimeMarker`均需提供一个ID（实现为一个`UUID`）以作为其唯一标识。

目前的设计中，所有引用其他`RelTimeMarker`的均需使用该ID进行引用，而非直接引用相应对象。

#### 完备性检查

在`Collection`类中有一个`is_self_contained()`方法，用来检查该`Collection`是否**完备**：其所包含的相对时间信息是否包含无效引用。

#### 一致性检查/冲突检查

一致性检查（或者叫冲突检查）是使用「非绝对时间」之后带来的一个必然的功能，用来检查记录之间的相对时间信息是否有冲突。比如事件A说自己早于事件B，而事件B也说自己早于事件A，这就是一个冲突。

一致性检查通过`OrderedMarkers`类完成，且该类将提供更多与此相关的功能。

目前看来，一致性检查的基本原理是将所有记录放在**图**中，用它们的相对时间信息作为边，然后检查图的一些属性。目前已实现的部分支持检查`RelTimeSpec`和`Event`：所有的`same`将会被组建并查集，将每个集合中每个元素的所有`before`和`after`信息聚合起来；然后以`after`为有向边，`before`反向建边；最后检查图中是否有环；若有环，则存在冲突，且环上的节点（及其集合内的全部节点）就是存在冲突的部分。

#### 数据存储

目前所有数据存在一个JSON文件中，通过`InfoRecDB`类来进行读取、写入、更新等操作。其背后调用`sede`模块。

或许拆分存储是更好的设计，以免单个JSON文件过大。使用专门的数据库也可能是更好的设计，但目前没必要，直到遇到性能瓶颈。

同时，如果可能，支持ontology描述更好，比如使用JSON-LD。

#### 需商榷设计

- `RelTimeSpec`对「空列表」和`None`的区分
- `RelTimeSpec`和`TimeRelativity`有一定重复，是否应用`TimeRelativity`来表述`RelTimeSpec`？（`RelTimeSpec`的设计较早）

#### 杂项

代码风格以[PEP-8](https://www.python.org/dev/peps/pep-0008/)为准。

暂时不确定用什么方法维护依赖环境，倾向于pipenv、poetry等直接维护环境的。
为了兼容性以及避免麻烦，依赖同时也写在`requirements.txt`中，以便通过`pip -r requirements.txt`安装。

有机会可以继续细分包，并提供`setup.py`等。
